# Разбор задач практики 05-221004

### 12-siof

##### Про условие

Задача [12-siof](https://github.com/hse-spb-2022-cpp/exercises/tree/master/05-221004#12-siof).
Сначала немножко про SIOF (static initialization order fiasco) --- на русский можно перевести как фиаско порядка статической инициализации:
* Фиаско случается, когда в одной единице трансляции переменная полагается на то, что переменная из другой единицы трансляции уже проинициализирована, что может происходить не всегда. 
Из-за этого переменная, зависящая от переменной из другой единицы трансляции, может быть непроинициализирована / проинициализирована некорректно.
* Также известно, что компиляторы собирают единицы трансляции в неопределенном порядке (том порядке, в каком захотели разработчики компиляторов). Например, на моём **железе**, на моей **версии операционной системы** (ubuntu1~20.04) с моими **версиями компиляторов** `g++` (10.3.0) и `clang++` (12.0.0) -- `g++` и `clang++` ведут себя одинаково при сборке **определенных файлов** -- файлов, из условия этой задачи: 
`g++-10 --std=c++17 main.cpp storage.cpp a.cpp z.cpp` и `clang++-12 --std=c++17 main.cpp storage.cpp a.cpp z.cpp` в моём **конкретном случае** собирают единицы трансляции слева-направо, в порядке передачи этих файлов как аргументов компилятору.

##### О задаче

В [условии задачи](https://github.com/hse-spb-2022-cpp/exercises/tree/master/05-221004/problem/12-siof) есть 4 единицы трансляции: 
* `storage.cpp` -- является "хранилилищем", содержащая вектор чисел `numbers`, и определяющая функцию `get_numbers` объявленную в `storage.hpp`, возвращающую ссылку на вектор `numbers`.
* `a.cpp` -- инициализирует глобальную переменную `initer_a` типа `InitierA`, которая в конструкторе добавляет в вектор, возвращаемый функцией `get_numbers` числа `10`, `20` и `30`.
* `z.cpp` -- инициализирует глобальную переменную `initer_z` типа `InitierZ`, которая в конструкторе добавляет в вектор, возвращаемый функцией `get_numbers` числа `100`, `200` и `300`.
* `main.cpp` -- содержит функцию `main`, точку входа в программу, и выводящая содержимое вектора, возвращаемого функцией `get_numbers`.

Поскольку `numbers` -- глобальная переменная в единице трансляции `storage.cpp`, то вектор чисел `numbers` может быть не проинициализирован, на момент конструирования `initer_a` / `initer_z` , из-за чего числа не будут добавлены по ссылке на непроинициализированный вектор `numbers` --- имеем SIOF.

Менять можно только файл `storage.cpp`, требуется избавиться от SIOF.

##### Разбор

Предлагается воспользоваться идиомой [construct on first use](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Construct_On_First_Use).

Будем инициализировать вектор `numbers` не как глобальную переменную в единице трансляции `storage.cpp`, а как переменную, имеющую static storage duration (про виды storage duration почитать можно [тут](https://en.cppreference.com/w/cpp/language/storage_duration)) -- хотим, чтобы `numbers` инициализировалась при первом вызове функции `get_numbers`. 
Для этого воспользуемся идиомой construct on first use, для этого проинициализируем переменную единожды, при вызове функции `get_numbers`, при помощи ключевого слова `static`.

Отрефакторенный файл `storage.cpp` будет выглядеть так:
```
#include "storage.hpp"

namespace exercise {
std::vector<int> &get_numbers() {
    static std::vector<int> numbers;
    return numbers;
}
}  // namespace exercise
```

Решение лежит [тут](https://github.com/hse-spb-2022-cpp/exercises/tree/master/05-221004/solution/12-siof).
